package com.example.user.ndkdebug;

/**
 *
 * 树相关的思维导图：
 *
 * 基于比较的树：
 *      ---> 二叉树
 *          ---> 无序二叉树
 *          ---> 有序二叉树
 *              ---> 平衡二叉树（有序存在退化线性链表问题）
 *                  ---> AVL树
 *                  ---> 红黑树
 *      ---> 多路查找树（为何要多路？减少I/O操作）
 *          ---> B树
 *          ---> B+树
 *
 * 不基于比较的树：
 *      ---> 哈希树
 *          ---> Trie树
 *
 *
 * 二叉树的基本操作：
 * 1. 树高：（深度）
 *      递归：左子树高 < 右子树高 ? （右子树高 + 1） ：（左子树 + 1）
 *
 * 2. 遍历
 *    深度遍历：
 *      包括先序、中序、后序，分别有递归、非递归版本（借助Stack）
 *    广度遍历：
 *      层次遍历，借助Queue。进行offer、poll
 *
 * 3. 判断一棵二叉树是否是平衡二叉树
 *      递归。
 *      求左、右子树高；
 *      若左、右子树高相差>1，则不是平衡；否则递归判断左孩子平衡 && 右孩子平衡
 *
 *    判断完全二叉树
 *      （ 若设二叉树的深度为h，除第h 层外，其它各层(1～h-1) 的结点数都达到最大个数，
 *          第h 层所有的结点都连续集中在最左边，这就是完全二叉树 ）
 *       （层序遍历）将二叉树进行遍历，设置一个标志位，当遇到一个空节点时，将标志位为修改；
 *       当后面在遇到有效节点并且标志位被修改时，则该二叉树不是完全二叉树。
 *       TODO：如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树； ？
 *       https://blog.csdn.net/gogogo_sky/article/details/76223384
 *
 *    判断满二叉树
 *
 *
 * 4. 构造
 *    与当前节点值比较：
 *    比当前节点大的，放入右边
 *    比当前节点小的，放入左边
 *
 * 5. 大小
 *    size = 1 + size（左子树） + size(右子树)
 *
 * 6. 求叶子节点个数：
 *    num = num(左子树的叶节点) + num(右子树的叶节点)
 *
 * 7. 搜索、查找：判断一个节点是否在二叉树中
 *    二叉树有序（二叉排序树 (BST)）：递归，比较与当前节点值，在左或者右子树中查找
 *    二叉树无序：递归，分别在左子树、右子树中查找
 *
 * Created by user on 2018/10/16.
 */

/*
*
* 何为2-3树？
* 一个节点可以是二叉，也可以是三叉。
* 主要是看键的数量，有一个或者两个键值。
* 插入、删除：涉及的操作有结点的分裂、合并、补位
*
*
* 任何k叉树仅考虑水平维度的话，元素值都是递增的
* 对于k叉树而言，任何插入/删除操作都可以维持树的平衡
* 任何k叉树均可以分裂成二叉树
*
* 两种平衡二叉树：（由于BST存在退化为线性链表的问题）
*
* 1. 红黑树：
* 要求"部分"地达到平衡要求
* 搜索、插入、删除的复杂度：o(logN)
* 任何不平衡都会在三次旋转之内解决
* 应用：
*   广泛用在C++的STL中。map和set都是用红黑树实现的
*   epoll在内核中的实现，用红黑树管理事件块
*   nginx中，用红黑树管理timer等
*   Java的TreeMap
*   和 Linux、
* 特别：
*   1. 引入颜色这一个约束条件保持树的平衡
*   2. 通过旋转可以降低树的高度并转换颜色
*
*
* 2. AVL树：
* o(logN),与红黑相同
* 应用：Windows进程地址空间管理
* 实现思路：步步调整，步步平衡，是非常严格的平衡
* 高度平衡，代价比收益大，实际应用不多
*
* 真正理解红黑树，真正的：
* https://blog.csdn.net/dog250/article/details/46665743
* 从2-3树到红黑树，B/B+/B*树：
* https://blog.csdn.net/dog250/article/details/81151687
* 二叉排序树、红黑树、AVL树最简单的理解：
* https://blog.csdn.net/linshijun33/article/details/53455149
*
* 多路查找树：
* B树、B+树
* 应用：磁盘文件组织 数据索引和数据库索引
*
* 哈希树：
* 非比较的查询树；
* 理论基础：
*   质数分辨定理：n个不同的质数可以“分辨”的连续整数的个数和他们的乘积相等
*   比如：质数2、3可以分辨 2*3=6 个整数：1、2、3、4、5、6，但是就无法分辨7
*
* 对质数进行取余操作得到的余数决定了处理的路径。
* 优点：
*   1. 结构简单
*   2. 查找迅速
*       不超过O(10)（哈希树层级最多能增加到10。因此最多只需要十次取余和比较操作）
*   3. 结构不变
*       删除的时候，并不做任何结构调整（“占位标记”置为false即可）
*  缺点：
*   非排序性
*
* 应用：
*   需要对大容量数据进行快速匹配操作的地方
*   统计词频、排序、查找
*   Trie（字典树、前缀树）
*       每个结点包括26个孩子结点
*       插入和查询时间复杂度都为 O(k) ，其中 k 为 key 的长度
*
* 哈希树HashTree(trie树)：
* https://blog.csdn.net/samjustin1/article/details/52250961
*
* */

public class TreeTest {



}
