package com.example.user.ndkdebug;

/**
 * 二叉树的基本操作：
 * 1. 树高：（深度）
 *      递归：左子树高 < 右子树高 ? （右子树高 + 1） ：（左子树 + 1）
 *
 * 2. 遍历
 *    深度遍历：
 *      包括先序、中序、后序，分别有递归、非递归版本（借助Stack）
 *    广度遍历：
 *      层次遍历，借助Queue。进行offer、poll
 *
 * 3. 判断一棵二叉树是否是平衡二叉树
 *      递归。
 *      求左、右子树高；
 *      若左、右子树高相差>1，则不是平衡；否则递归判断左孩子平衡 && 右孩子平衡
 *
 *    判断完全二叉树
 *      （ 若设二叉树的深度为h，除第h 层外，其它各层(1～h-1) 的结点数都达到最大个数，
 *          第h 层所有的结点都连续集中在最左边，这就是完全二叉树 ）
 *       （层序遍历）将二叉树进行遍历，设置一个标志位，当遇到一个空节点时，将标志位为修改；
 *       当后面在遇到有效节点并且标志位被修改时，则该二叉树不是完全二叉树。
 *       TODO：如果遇到一个结点，左孩子为空，右孩子不为空，则该树一定不是完全二叉树； ？
 *       https://blog.csdn.net/gogogo_sky/article/details/76223384
 *
 *    判断满二叉树
 *
 *
 * 4. 构造
 *    与当前节点值比较：
 *    比当前节点大的，放入右边
 *    比当前节点小的，放入左边
 *
 * 5. 大小
 *    size = 1 + size（左子树） + size(右子树)
 *
 * 6. 求叶子节点个数：
 *    num = num(左子树的叶节点) + num(右子树的叶节点)
 *
 * 7. 搜索、查找：判断一个节点是否在二叉树中
 *    二叉树有序：递归，比较与当前节点值，在左或者右子树中查找
 *    二叉树无序：递归，分别在左子树、右子树中查找
 *
 * Created by user on 2018/10/16.
 */

public class TreeTest {
}
